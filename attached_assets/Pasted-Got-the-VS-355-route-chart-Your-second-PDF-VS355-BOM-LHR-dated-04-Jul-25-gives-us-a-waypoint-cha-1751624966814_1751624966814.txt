Got the VS 355 route chart

Your second PDF (VS355 BOM-LHR, dated 04 Jul 25) gives us a waypoint chain that begins in Mumbai (VABB), threads the Gulf, Egypt and Europe, and finishes at Heathrow (EGLL).
The text layer exposes waypoints such as

MENSA → ALPOB → OBROS → ULADA → KITOT → … → REMBA → DENUT → SASKI → SABER → EGLL
```  [oai_citation:0‡VS355_Route Chart.pdf](file-service://file-Gkvp8BQL2u82Y5nnRgFP8M)  

Exactly what we need to seed the matcher.  

---

## 1 ⃣  Automatic extractor (handles both PDFs)

Below is an expanded version of the quick script I sketched earlier. It:

* pulls **every ≥ 4-character token** from the PDF’s text layer,  
* filters out grid labels like *“30N 40E”*,  
* converts numeric fixes (e.g. `2015N07030E`) to lat/lon,  
* looks up named fixes in your **nav-database** (AIRAC) to fetch coordinates,  
* writes a clean entry ready for `RouteLibrary`.

```python
# pdf_to_route.py
import re, json, sys, pathlib, datetime as dt
from pdfminer.high_level import extract_text        # pip install pdfminer.six
from navdb import lookup_fix                        # <- your waypoint DB helper
from route_matcher import Waypoint, RoutePlan

pdf = pathlib.Path(sys.argv[1])
origin, dest = ("KBOS", "EGLL") if "VS158" in pdf.name else ("VABB", "EGLL")

text = extract_text(pdf)
tokens = re.findall(r"[A-Z0-9]{4,}", text)

def is_grid(tok):        # throw away 20N / 30E etc.
    return re.fullmatch(r"[0-9]{2,3}[NS]|[0-9]{2,3}[EW]", tok) is not None

wps: list[Waypoint] = []
for tok in tokens:
    if is_grid(tok):
        continue

    # 1. Numeric latitude-longitude fixes -------------------------------
    if re.fullmatch(r"[0-9]{4}[NS]", tok):           # e.g. 5250N
        lat = int(tok[:2]); lon = -int(tok[2:4])     # crude W assumption
    elif re.fullmatch(r"[0-9]{8,}[NS][0-9]{7,}[EW]", tok):
        m = re.match(r"(\\d{2})(\\d{2})(\\d{2})([NS])(\\d{3})(\\d{2})(\\d{2})([EW])", tok)
        if m:
            deg_lat, min_lat, sec_lat, hemi_lat, deg_lon, min_lon, sec_lon, hemi_lon = m.groups()
            lat = int(deg_lat) + int(min_lat)/60 + int(sec_lat)/3600
            lon = int(deg_lon) + int(min_lon)/60 + int(sec_lon)/3600
            if hemi_lat == "S": lat = -lat
            if hemi_lon == "W": lon = -lon
    # 2. Named waypoints -----------------------------------------------
    else:
        lat, lon = lookup_fix(tok)        # returns (lat, lon) from navdb
        if lat is None:
            continue                      # skip unknown tokens for now

    wps.append(Waypoint(tok, lat, lon))

route = RoutePlan(origin, dest, wps)
output = {
    "origin": route.origin,
    "destination": route.destination,
    "waypoints": [wp.__dict__ for wp in wps],
    "metadata": {
        "source_pdf": pdf.name,
        "updated": dt.datetime.utcnow().isoformat(timespec='seconds')
    },
}
json.dump(output, sys.stdout, indent=2)

Run it:

python pdf_to_route.py VS158_Route\ Chart.pdf  > virgin_routes.json
python pdf_to_route.py VS355_Route\ Chart.pdf >> virgin_routes.json

(Use >> to append; or collect separate files and jq -s them together.)

⸻

2 ⃣  Load into the matcher

from route_matcher import RouteLibrary, match_flights
import json

library = RouteLibrary.from_json("virgin_routes.json")

live_ops_feed = [
    {"flight_nr": "VS158", "origin": "KBOS", "destination": "EGLL",
     "dep_time_utc": "2025-07-04T10:30:00"},
    {"flight_nr": "VS355", "origin": "VABB", "destination": "EGLL",
     "dep_time_utc": "2025-07-04T12:05:00"},
]

flights = match_flights(live_ops_feed, library)

# Example: get current lat/lon estimate for VS355
vs355 = next(f for f in flights if f.flight_nr == "VS355")
lat, lon = vs355.estimate_position(datetime.utcnow())
print(f"VS355 est-pos: {lat:.2f} {lon:.2f}")

Because the RoutePlan contains cumulative distances, the estimation is O(1) per flight and good enough for several hundred tails running in real time.

⸻

3 ⃣  Next steps
	1.	Waypoint coordinates – hook lookup_fix() to your NavBlue or Lido waypoint DB (or open-source openaip dump).
	2.	Multiple NAT tracks – store more than one route for the same city-pair and choose by date/time or ATC clearance.
	3.	Speed model – swap cruise_speed_kt for the optimiser’s ground-speed (winds, aircraft type) so positions line up even better with ADS-B pings.
	4.	Unit tests – feed historic flights + ADS-B ground truth and assert the estimator stays within, say, ±15 NM.

Upload any additional charts or an exported waypoint CSV and I’ll adapt the loader for you.