# route_matcher.py
# ---------------------------------------------------------------------------
# Match active/completed flights to a library of typical routings so the
# system can continuously estimate each aircraft's geographic position.
# ---------------------------------------------------------------------------
# How it works (quick sketch):
# • Your scheduling / operations DB feeds a list of flights (flight-nr, dep
#   time, origin, destination, equipment).
# • A RouteLibrary (loaded from JSON, YAML, DB - whatever) maps each
#   origin-dest pair to an ordered list of waypoints (lat/lon).
# • When the tracker starts it attaches the most likely RoutePlan to each
#   flight.  If no bespoke plan exists it falls back to a great-circle
#   skeleton.
# • As time progresses `estimate_position()` walks along the polyline in
#   proportion to elapsed-time × average GS to return the current lat/lon.
#   You can refine GS using aircraft type, winds aloft, or clusters of ADS-B
#   history; the hook is exposed.
# ---------------------------------------------------------------------------
from __future__ import annotations

import json
import math
import datetime as dt
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Iterable, Callable

EARTH_RADIUS_NM = 3440.065
DEG2RAD = math.pi / 180.0
RAD2DEG = 180.0 / math.pi

# ---------------------------------------------------------------------------
# Geo helpers
# ---------------------------------------------------------------------------

def haversine_nm(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    lat1, lon1, lat2, lon2 = map(lambda x: x * DEG2RAD, (lat1, lon1, lat2, lon2))
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = (
        math.sin(dlat / 2) ** 2
        + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
    )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return EARTH_RADIUS_NM * c


def interpolate_great_circle(
    lat1: float, lon1: float, lat2: float, lon2: float, f: float
) -> Tuple[float, float]:
    """Return lat/lon a fraction f along the great-circle between A and B."""
    lat1, lon1, lat2, lon2 = map(lambda x: x * DEG2RAD, (lat1, lon1, lat2, lon2))
    d = haversine_nm(lat1 * RAD2DEG, lon1 * RAD2DEG, lat2 * RAD2DEG, lon2 * RAD2DEG) / EARTH_RADIUS_NM
    if d == 0:
        return lat1 * RAD2DEG, lon1 * RAD2DEG

    a = math.sin((1 - f) * d) / math.sin(d)
    b = math.sin(f * d) / math.sin(d)
    x = a * math.cos(lat1) * math.cos(lon1) + b * math.cos(lat2) * math.cos(lon2)
    y = a * math.cos(lat1) * math.sin(lon1) + b * math.cos(lat2) * math.sin(lon2)
    z = a * math.sin(lat1) + b * math.sin(lat2)
    lat = math.atan2(z, math.sqrt(x ** 2 + y ** 2))
    lon = math.atan2(y, x)
    return lat * RAD2DEG, lon * RAD2DEG

# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------

@dataclass
class Waypoint:
    name: str
    lat: float
    lon: float
    cumulative_nm: float = 0  # filled in by RoutePlan


@dataclass
class RoutePlan:
    origin: str
    destination: str
    waypoints: List[Waypoint]
    total_nm: float = field(init=False)

    def __post_init__(self):
        # Pre-compute cumulative distances for fast position lookup
        cum = 0.0
        for i, wp in enumerate(self.waypoints):
            if i > 0:
                prev = self.waypoints[i - 1]
                seg = haversine_nm(prev.lat, prev.lon, wp.lat, wp.lon)
                cum += seg
            wp.cumulative_nm = cum
        self.total_nm = cum


class RouteLibrary:
    """Storage / lookup for predefined city-pair routings."""

    def __init__(self, mapping: Dict[Tuple[str, str], RoutePlan]):
        self._map = mapping

    @staticmethod
    def from_json(path: str | Path) -> "RouteLibrary":
        with open(path) as f:
            raw = json.load(f)
        mapping: Dict[Tuple[str, str], RoutePlan] = {}
        for entry in raw:  # expect list of {origin,destination,waypoints:[{name,lat,lon}]}
            wps = [Waypoint(**wp) for wp in entry["waypoints"]]
            mapping[(entry["origin"], entry["destination"])] = RoutePlan(
                origin=entry["origin"], destination=entry["destination"], waypoints=wps
            )
        return RouteLibrary(mapping)

    def get(self, origin: str, destination: str) -> Optional[RoutePlan]:
        return self._map.get((origin, destination))


@dataclass
class Flight:
    flight_nr: str
    origin: str
    destination: str
    dep_time_utc: dt.datetime  # scheduled or actual – use UTC
    cruise_speed_kt: float  # typical ground speed - adjust w/ winds later
    route: RoutePlan

    # Cached values for performance
    _cum_dists: List[float] = field(init=False, repr=False)
    _lats: List[float] = field(init=False, repr=False)
    _lons: List[float] = field(init=False, repr=False)

    def __post_init__(self):
        self._cum_dists = [wp.cumulative_nm for wp in self.route.waypoints]
        self._lats = [wp.lat for wp in self.route.waypoints]
        self._lons = [wp.lon for wp in self.route.waypoints]

    def elapsed_hours(self, now: dt.datetime) -> float:
        return max((now - self.dep_time_utc).total_seconds() / 3600.0, 0.0)

    def distance_flown_nm(self, now: dt.datetime) -> float:
        return self.elapsed_hours(now) * (self.cruise_speed_kt / 1.852)  # kt to km/h? Wait: nm/h == kt

    def estimate_position(self, now: dt.datetime) -> Tuple[float, float]:
        dist = self.distance_flown_nm(now)
        if dist >= self.route.total_nm:
            # arrived – return destination coords
            last = self.route.waypoints[-1]
            return last.lat, last.lon

        # Find segment containing dist (linear scan is fine for ~<50 waypoints). Binary search for big lists
        for i in range(1, len(self._cum_dists)):
            if dist <= self._cum_dists[i]:
                seg_start = self._cum_dists[i - 1]
                seg_end = self._cum_dists[i]
                f = (dist - seg_start) / (seg_end - seg_start)
                lat, lon = interpolate_great_circle(
                    self._lats[i - 1], self._lons[i - 1], self._lats[i], self._lons[i], f
                )
                return lat, lon

        # Fallback – shouldn’t reach here
        return self._lats[-1], self._lons[-1]


# ---------------------------------------------------------------------------
# Factory – match flights to routes
# ---------------------------------------------------------------------------

def match_flights(
    flights_raw: Iterable[Dict],
    route_lib: RouteLibrary,
    cruise_speed_fn: Callable[[Dict], float] | None = None,
) -> List[Flight]:
    """Return a list of Flight objects with an attached RoutePlan.

    flights_raw: Iterable of dicts expected keys {flight_nr, origin, destination, dep_time_utc ISO str}
    cruise_speed_fn: Optional fn to derive cruise GS (kt) from flight-raw row.
    """
    flights: List[Flight] = []
    default_speed_kt = 450  # generic jet

    for row in flights_raw:
        route = route_lib.get(row["origin"], row["destination"])
        if route is None:
            # Fallback: great-circle (origin + dest only)
            ori = route_lib.get(row["origin"], row["origin"])
            dest = route_lib.get(row["destination"], row["destination"])
            wps = [
                Waypoint(row["origin"], ori.waypoints[0].lat if ori else 0, ori.waypoints[0].lon if ori else 0),
                Waypoint(row["destination"], dest.waypoints[-1].lat if dest else 0, dest.waypoints[-1].lon if dest else 0),
            ]
            route = RoutePlan(row["origin"], row["destination"], wps)
        speed_kt = cruise_speed_fn(row) if cruise_speed_fn else default_speed_kt
        dep_time = dt.datetime.fromisoformat(row["dep_time_utc"])
        flights.append(
            Flight(
                flight_nr=row["flight_nr"],
                origin=row["origin"],
                destination=row["destination"],
                dep_time_utc=dep_time,
                cruise_speed_kt=speed_kt,
                route=route,
            )
        )
    return flights


# ---------------------------------------------------------------------------
# Example stub
# ---------------------------------------------------------------------------
if __name__ == "__main__":
    # Fake mini route map: EGLL-KJFK via DOGAL… NAT track… OXANA
    lib_json = [
        {
            "origin": "EGLL",
            "destination": "KJFK",
            "waypoints": [
                {"name": "EGLL", "lat": 51.4706, "lon": -0.4619},
                {"name": "DOGAL", "lat": 53.6483, "lon": -7.6917},
                {"name": "SOMAX", "lat": 55.7533, "lon": -15.0},
                {"name": "55N020W", "lat": 55.0, "lon": -20.0},
                {"name": "52N040W", "lat": 52.0, "lon": -40.0},
                {"name": "NORMY", "lat": 45.07, "lon": -60.0},
                {"name": "KESNO", "lat": 44.505, "lon": -70.0},
                {"name": "CAM", "lat": 43.892, "lon": -73.527},
                {"name": "KJFK", "lat": 40.6413, "lon": -73.7781},
            ],
        }
    ]
    tmp = Path("/tmp/mini_lib.json")
    tmp.write_text(json.dumps(lib_json, indent=2))

    library = RouteLibrary.from_json(tmp)

    flights_raw = [
        {
            "flight_nr": "VS3",
            "origin": "EGLL",
            "destination": "KJFK",
            "dep_time_utc": dt.datetime.utcnow().isoformat(timespec="seconds"),
        }
    ]

    flights = match_flights(flights_raw, library)
    vs3 = flights[0]

    # Fast-forward two hours to test position
    now = dt.datetime.utcnow() + dt.timedelta(hours=2)
    lat, lon = vs3.estimate_position(now)
    print(f"VS3 estimated position after 2h: {lat:.2f}, {lon:.2f}")
