MENSA → ALPOB → OBROS → ULADA → KITOT → … → REMBA → DENUT → SASKI → SABER → EGLL
```  [oai_citation:0‡VS355_Route Chart.pdf](file-service://file-Gkvp8BQL2u82Y5nnRgFP8M)  

Exactly what we need to seed the matcher.  

---

## 1 ⃣  Automatic extractor (handles both PDFs)

Below is an expanded version of the quick script I sketched earlier. It:

* pulls **every ≥ 4-character token** from the PDF’s text layer,  
* filters out grid labels like *“30N 40E”*,  
* converts numeric fixes (e.g. `2015N07030E`) to lat/lon,  
* looks up named fixes in your **nav-database** (AIRAC) to fetch coordinates,  
* writes a clean entry ready for `RouteLibrary`.

```python
# pdf_to_route.py
import re, json, sys, pathlib, datetime as dt
from pdfminer.high_level import extract_text        # pip install pdfminer.six
from navdb import lookup_fix                        # <- your waypoint DB helper
from route_matcher import Waypoint, RoutePlan

pdf = pathlib.Path(sys.argv[1])
origin, dest = ("KBOS", "EGLL") if "VS158" in pdf.name else ("VABB", "EGLL")

text = extract_text(pdf)
tokens = re.findall(r"[A-Z0-9]{4,}", text)

def is_grid(tok):        # throw away 20N / 30E etc.
    return re.fullmatch(r"[0-9]{2,3}[NS]|[0-9]{2,3}[EW]", tok) is not None

wps: list[Waypoint] = []
for tok in tokens:
    if is_grid(tok):
        continue

    # 1. Numeric latitude-longitude fixes -------------------------------
    if re.fullmatch(r"[0-9]{4}[NS]", tok):           # e.g. 5250N
        lat = int(tok[:2]); lon = -int(tok[2:4])     # crude W assumption
    elif re.fullmatch(r"[0-9]{8,}[NS][0-9]{7,}[EW]", tok):
        m = re.match(r"(\\d{2})(\\d{2})(\\d{2})([NS])(\\d{3})(\\d{2})(\\d{2})([EW])", tok)
        if m:
            deg_lat, min_lat, sec_lat, hemi_lat, deg_lon, min_lon, sec_lon, hemi_lon = m.groups()
            lat = int(deg_lat) + int(min_lat)/60 + int(sec_lat)/3600
            lon = int(deg_lon) + int(min_lon)/60 + int(sec_lon)/3600
            if hemi_lat == "S": lat = -lat
            if hemi_lon == "W": lon = -lon
    # 2. Named waypoints -----------------------------------------------
    else:
        lat, lon = lookup_fix(tok)        # returns (lat, lon) from navdb
        if lat is None:
            continue                      # skip unknown tokens for now

    wps.append(Waypoint(tok, lat, lon))

route = RoutePlan(origin, dest, wps)
output = {
    "origin": route.origin,
    "destination": route.destination,
    "waypoints": [wp.__dict__ for wp in wps],
    "metadata": {
        "source_pdf": pdf.name,
        "updated": dt.datetime.utcnow().isoformat(timespec='seconds')
    },
}
json.dump(output, sys.stdout, indent=2)