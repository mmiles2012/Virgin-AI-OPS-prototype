"""
Diversion Planner – Hybrid Path-Planning & Optimal Control Skeleton
==================================================================
This module provides a **reference implementation** of the hybrid diversion
pipeline we discussed:

1. **Graph-based A\* search** for a quick, hazard-avoiding route.
2. **Trajectory polish** with optimal control (CasADi) when time permits.
3. **Multi-criteria scoring** to pick the most suitable diversion airfield.

Designed for integration in a Python-based flight-ops platform. All heavy
numerics are isolated so you can swap in C++ or accelerated back-ends later.

Dependencies (PyPI):
    numpy, shapely, networkx, casadi (optional, for step-2), pandas, rich

Install:
    pip install numpy shapely networkx casadi pandas rich

© 2025 Your Company – MIT License
"""
from __future__ import annotations

import math
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Tuple, Optional, Dict

import numpy as np
from shapely.geometry import Point, Polygon, LineString
from shapely.ops import unary_union
import networkx as nx

# Optional: only needed if you enable trajectory optimisation
try:
    import casadi as ca
except ImportError:  # pragma: no cover – allow import-free deployment
    ca = None  # type: ignore

# ---------------------------------------------------------------------------
# 1. Data structures
# ---------------------------------------------------------------------------

@dataclass
class AircraftState:
    """4-D aircraft state."""
    lat: float
    lon: float
    alt_ft: float
    gs_kt: float  # ground speed (knots)
    heading_deg: float

    timestamp: datetime = field(default_factory=datetime.utcnow)

    def to_xy(self) -> np.ndarray:
        """Return (x, y) in NM using simple equirect projection around origin."""
        R_nm = 3440.065  # Earth radius in nautical miles
        x = math.radians(self.lon) * R_nm * math.cos(math.radians(self.lat))
        y = math.radians(self.lat) * R_nm
        return np.array([x, y])


@dataclass
class HazardZone:
    """Static or slowly moving polygon hazard (e.g. convective cell)."""
    poly: Polygon
    expiry: datetime
    severity: str  # e.g. "light", "moderate", "severe"
    id: str = field(default_factory=lambda: uuid.uuid4().hex)

    def is_active(self, t: datetime) -> bool:
        return t <= self.expiry


@dataclass
class Airfield:
    icao: str
    lat: float
    lon: float
    elev_ft: float
    longest_runway_ft: int
    fuel_available: bool = True

    def to_xy(self, ref_lat: float) -> np.ndarray:
        R_nm = 3440.065
        x = math.radians(self.lon) * R_nm * math.cos(math.radians(ref_lat))
        y = math.radians(self.lat) * R_nm
        return np.array([x, y])


@dataclass
class CandidateRoute:
    waypoints: List[Tuple[float, float]]  # (lat, lon) list
    total_nm: float
    fuel_kg: float
    eta: datetime
    score: float  # aggregate multi-criteria score – lower is better
    target_airfield: Airfield


# ---------------------------------------------------------------------------
# 2. A* path planner
# ---------------------------------------------------------------------------

def build_airspace_graph(
    origin: Tuple[float, float],
    dest: Tuple[float, float],
    hazards: List[HazardZone],
    grid_nm: float = 10.0,
    search_radius_nm: float = 500.0,
) -> nx.Graph:
    """Return a 2-D grid graph around the origin-dest line, minus hazard cells."""
    ox, oy = origin
    dx, dy = dest

    min_x, max_x = sorted([ox, dx])
    min_y, max_y = sorted([oy, dy])
    margin = search_radius_nm
    xs = np.arange(min_x - margin, max_x + margin, grid_nm)
    ys = np.arange(min_y - margin, max_y + margin, grid_nm)

    G = nx.Graph()
    hazard_union = unary_union([h.poly for h in hazards if h.is_active(datetime.utcnow())])

    for x in xs:
        for y in ys:
            p = Point(x, y)
            if hazard_union and hazard_union.buffer(0.1).contains(p):
                continue  # skip node inside hazard + small buffer (~0.1 NM)
            G.add_node((x, y))

    # connect 8-neighbours
    for x in xs:
        for y in ys:
            if (x, y) not in G:
                continue
            for dx_ in (-grid_nm, 0, grid_nm):
                for dy_ in (-grid_nm, 0, grid_nm):
                    if dx_ == dy_ == 0:
                        continue
                    nbr = (x + dx_, y + dy_)
                    if nbr in G:
                        G.add_edge((x, y), nbr, weight=math.hypot(dx_, dy_))
    return G


def heuristic(a: Tuple[float, float], b: Tuple[float, float]) -> float:
    """Euclidean distance (NM) – admissible heuristic for A*."""
    return math.hypot(a[0] - b[0], a[1] - b[1])


def plan_path_a_star(
    origin_latlon: Tuple[float, float],
    dest_latlon: Tuple[float, float],
    hazards: List[HazardZone],
) -> List[Tuple[float, float]]:
    """Return waypoint list (lat, lon) from origin to dest using A*."""
    # Project to x, y NM (equirect at origin lat)
    ref_lat = origin_latlon[0]
    def proj(lat, lon):
        R = 3440.065
        x = math.radians(lon) * R * math.cos(math.radians(ref_lat))
        y = math.radians(lat) * R
        return x, y

    origin_xy = proj(*origin_latlon)
    dest_xy = proj(*dest_latlon)

    G = build_airspace_graph(origin_xy, dest_xy, hazards)

    try:
        path_xy = nx.astar_path(G, origin_xy, dest_xy,
                                heuristic=lambda a, b: heuristic(a, b),
                                weight="weight")
    except nx.NetworkXNoPath:
        raise RuntimeError("No diversion path found – entire corridor blocked.")

    # Back-project to lat/lon
    inv = lambda x, y: (
        math.degrees(y / 3440.065),
        math.degrees(x / (3440.065 * math.cos(math.radians(ref_lat))))
    )
    return [inv(x, y) for x, y in path_xy]


# ---------------------------------------------------------------------------
# 3. Trajectory refinement (optional)
# ---------------------------------------------------------------------------

def refine_trajectory_optimal_control(
    waypoints: List[Tuple[float, float]],
    aircraft: AircraftState,
    optimize_for: str = "fuel",
    time_horizon_min: int = 30,
) -> List[Tuple[float, float]]:
    """Polish coarse waypoints using CasADi to solve an OCP.

    Returns new waypoint list (may be much denser). If CasADi is unavailable
    at runtime the function returns the input waypoints unchanged.
    """
    if ca is None:
        print("[warn] CasADi not installed – skipping trajectory optimisation.")
        return waypoints

    N = len(waypoints) - 1  # segments
    T = time_horizon_min * 60  # seconds

    # Decision variables: waypoint perturbations (dx, dy) and segment times
    opti = ca.Opti()
    dxy = opti.variable(N, 2)
    dt = opti.variable(N)

    # Parameters
    wp = np.array(waypoints)
    gs = aircraft.gs_kt * 0.51444  # m/s

    # Objective: minimise sum(dt) or sum(fuel) ~ dt * throttle
    if optimize_for == "time":
        opti.minimize(ca.sumsqr(dt))
    else:  # fuel ~ time for cruise, simple proxy
        opti.minimize(ca.sumsqr(dt))

    # Dynamics: distance = gs * dt (simple straight-line assumption)
    for i in range(N):
        dx = (wp[i+1, 0] + dxy[i, 0]) - (wp[i, 0] + (dxy[i-1, 0] if i else 0))
        dy = (wp[i+1, 1] + dxy[i, 1]) - (wp[i, 1] + (dxy[i-1, 1] if i else 0))
        dist = ca.sqrt(dx**2 + dy**2) * 1852  # deg lat ~ NM? simplified
        opti.subject_to(dist <= gs * dt[i])
        opti.subject_to(dt[i] > 0)

    # Smoothness: bound perturbations
    opti.subject_to(ca.fabs(dxy) <= 1.0)  # ≤1 NM tweak each segment

    # Total horizon constraint
    opti.subject_to(ca.sum1(dt) <= T)

    # Solver
    opti.solver("ipopt", {"print_time": 0}, {"print_level": 0})
    try:
        sol = opti.solve()
        dxy_opt = sol.value(dxy)
        refined = [(lat + dx, lon + dy) for (lat, lon), (dx, dy) in zip(waypoints, dxy_opt)] + [waypoints[-1]]
        return refined
    except RuntimeError:
        print("[warn] OCP failed – returning coarse path.")
        return waypoints


# ---------------------------------------------------------------------------
# 4. Multi-criteria scoring
# ---------------------------------------------------------------------------

def score_route(
    waypoints: List[Tuple[float, float]],
    airfield: Airfield,
    weights: Dict[str, float] | None = None,
) -> float:
    """Return scalar score, lower ⇒ better."""
    weights = weights or {"distance": 0.5, "runway": 0.3, "fuel": 0.2}

    distance = sum(
        math.hypot(lat2 - lat1, lon2 - lon1) for (lat1, lon1), (lat2, lon2) in zip(waypoints, waypoints[1:])
    )
    runway_penalty = max(0, 8000 - airfield.longest_runway_ft) / 8000  # zero if ≥8000 ft, else up to 1
    fuel_proxy = distance  # naive

    return (
        weights["distance"] * distance +
        weights["runway"] * runway_penalty +
        weights["fuel"] * fuel_proxy
    )

# ---------------------------------------------------------------------------
# 5. High-level search orchestration
# ---------------------------------------------------------------------------

def find_best_diversion(
    aircraft: AircraftState,
    candidate_airfields: List[Airfield],
    hazards: List[HazardZone],
) -> CandidateRoute:
    """Evaluate each airfield and return best route & score."""
    best: Optional[CandidateRoute] = None
    for af in candidate_airfields:
        try:
            coarse_wp = plan_path_a_star(
                (aircraft.lat, aircraft.lon), (af.lat, af.lon), hazards
            )
            refined_wp = refine_trajectory_optimal_control(coarse_wp, aircraft)
            sc = score_route(refined_wp, af)
            total_nm = sum(
                math.hypot(a - b, c - d) for (a, c), (b, d) in zip(refined_wp, refined_wp[1:])
            )
            fuel_est = total_nm * 3.25  # placeholder: kg per NM
            eta = aircraft.timestamp + timedelta(hours=total_nm / aircraft.gs_kt)
            route = CandidateRoute(refined_wp, total_nm, fuel_est, eta, sc, af)
            if best is None or sc < best.score:
                best = route
        except RuntimeError as e:
            print(f"[info] {af.icao} skipped – {e}")
    if best is None:
        raise RuntimeError("No viable diversion found among airfields provided.")
    return best

# ---------------------------------------------------------------------------
# 6. CLI / REST glue (example only)
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    import argparse, json, sys

    parser = argparse.ArgumentParser(description="Diversion planner demo")
    parser.add_argument("--aircraft", type=str, help="JSON file with aircraft state")
    parser.add_argument("--airfields", type=str, help="JSON list of airfields")
    parser.add_argument("--hazards", type=str, help="GeoJSON hazards")
    args = parser.parse_args()

    ac = AircraftState(**json.load(open(args.aircraft)))
    afs = [Airfield(**d) for d in json.load(open(args.airfields))]
    hz_polys = json.load(open(args.hazards))
    hazards = [
        HazardZone(Polygon(f["coordinates"][0]), datetime.utcfromtimestamp(f["expiry"]), f.get("severity", "mod"))
        for f in hz_polys
    ]

    best = find_best_diversion(ac, afs, hazards)
    print("Best diversion:", best.target_airfield.icao)
    print("Score:", best.score)
    lp = [(round(lat, 4), round(lon, 4)) for lat, lon in best.waypoints]
    print("Waypoints:", lp)
